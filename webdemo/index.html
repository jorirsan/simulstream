<!--
  Copyright 2025 FBK

  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
-->
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>üéôÔ∏è FBK Simultaneous Translation Demo</title>
  <script src="https://cdn.jsdelivr.net/npm/js-yaml@4.1.0/dist/js-yaml.min.js"></script>
  <link rel="stylesheet" href="style.css">
</head>
<body>

  <div class="logo">
    <img src="FBK_white_transp.png" alt="Logo">
  </div>

  <div class="container">
    <h1>üéôÔ∏è FBK SimulST Demo</h1>
    <canvas id="visualizer"></canvas>
    <div class="language-selectors">
      <div class="language-selector">
        <label for="src_language">Input Language:</label>
        <select id="src_language">
        </select>
      </div>
      <div class="language-selector">
        <label for="tgt_language">Output Language:</label>
        <select id="tgt_language">
        </select>
      </div>
    </div>
    <div class="controls">
      <button id="startBtn">Start Recording</button>
      <button id="stopBtn" disabled>Stop Recording</button>
    </div>
    <p id="status"><span class="pulse red"></span>Status: Idle</p>
    <div id="transcript-box">
      <h3>Output</h3>
      <div id="transcript-text"></div>
    </div>
  </div>

  <div id="credits" class="footer">
    <span>Powered by <strong id="credits_model_name"></strong></span>
  </div>

  <script>
    async function loadConfig(url) {
      try {
        const response = await fetch(url);

        if (!response.ok) {
          throw new Error(`HTTP error! Status: ${response.status}`);
        }

        const yamlText = await response.text();
        const data = jsyaml.load(yamlText);

        console.log("Parsed YAML:", data);
        return data;
      } catch (error) {
        console.error("Error loading YAML:", error);
      }
    }

    // Example usage
    const configLoader = loadConfig('../config/server.yaml');

    let stream;
    let socket;
    let processorNode;
    let audioContext;
    let analyser;
    let dataArray;
    let source;
    let animationId;

    const canvas = document.getElementById('visualizer');
    const ctx = canvas.getContext('2d');

    const startBtn = document.getElementById('startBtn');
    const stopBtn = document.getElementById('stopBtn');
    const statusText = document.getElementById('status');

    configLoader.then(function (config_yaml) {
      const config = config_yaml.webui
      if (config.tgt_supported_langs) {
        const langSelect = document.getElementById('tgt_language');
        for (var i = 0; i < config.tgt_supported_langs.length; ++i) {
          Object.entries(config.tgt_supported_langs[i]).forEach(([langId, langText]) => {
            const langOpt = document.createElement('option');
            langOpt.value = langId;
            langOpt.text = langText;
            langSelect.append(langOpt);
          });
        }
      }
      if (config.src_supported_langs) {
        const langSelect = document.getElementById('src_language');
        for (var i = 0; i < config.src_supported_langs.length; ++i) {
          Object.entries(config.src_supported_langs[i]).forEach(([langId, langText]) => {
            const langOpt = document.createElement('option');
            langOpt.value = langId;
            langOpt.text = langText;
            langSelect.append(langOpt);
          });
        }
      }
      const credits = document.getElementById('credits');
      if (config.model_name) {
        document.getElementById('credits_model_name').textContent = config.model_name;
        if (config.model_logo) {
          const logoImg = document.createElement('img');
          logoImg.src = config.model_logo;
          logoImg.className = 'footer-logo';
          logoImg.alt = config.model_name + ' logo';
          credits.prepend(logoImg);
        }
      }
    });

    function updateStatus(text, color = 'red') {
      statusText.textContent = '';
      const pulse = document.createElement('span');
      pulse.className = `pulse ${color}`;
      statusText.appendChild(pulse);
      statusText.append(` ${text}`);
    }

    function drawVisualizer() {
      if (!analyser) return;
      animationId = requestAnimationFrame(drawVisualizer);

      analyser.getByteTimeDomainData(dataArray);
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.lineWidth = 2;
      ctx.strokeStyle = '#3b82f6';
      ctx.beginPath();

      const sliceWidth = canvas.width / dataArray.length;
      let x = 0;

      for (let i = 0; i < dataArray.length; i++) {
        const v = dataArray[i] / 128.0;
        const y = v * canvas.height / 2;

        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);

        x += sliceWidth;
      }

      ctx.lineTo(canvas.width, canvas.height / 2);
      ctx.stroke();
    }

    function float32ToInt16(float32) {
      const int16 = new Int16Array(float32.length);
      for (let i = 0; i < float32.length; i++) {
        let s = float32[i] * 32768;
        int16[i] = Math.max(-32768, Math.min(32767, s));
      }
      return int16;
    }

    startBtn.addEventListener('click', async () => {
      if (!navigator.mediaDevices) {
        alert("Your browser doesn't support audio recording.");
        return;
      }

      try {
        stream = await navigator.mediaDevices.getUserMedia({ audio: true });

        audioContext = new (window.AudioContext || window.webkitAudioContext)();
        const inputSampleRate = audioContext.sampleRate;
        // Visualizer Setup
        analyser = audioContext.createAnalyser();
        analyser.fftSize = 2048;
        dataArray = new Uint8Array(analyser.frequencyBinCount);
        source = audioContext.createMediaStreamSource(stream);
        source.connect(analyser);
        drawVisualizer();

        // WebSocket Setup
        const websocker_url = await configLoader.then(function (config) {
          const secure = config.secure ? 's' : '';
          return 'ws' + secure + '://' + config.hostname + ':' + config.port;
        });
        if (socket) {
          socket.close();
          const transcriptText = document.getElementById('transcript-text');
          transcriptText.textContent = '';
        }
        socket = new WebSocket(websocker_url);

        socket.onopen = () => {
          updateStatus("Connected & Recording...", 'green');
          let tgt_lang = document.getElementById("tgt_language").value;
          let src_lang = document.getElementById("src_language").value;
          socket.send(JSON.stringify({
            target_lang: tgt_lang, source_lang: src_lang, sample_rate: inputSampleRate
          }));
        };

        socket.onerror = () => {
          updateStatus("WebSocket error.", 'red');
        };

        socket.onmessage = (event) => {
          const transcription = JSON.parse(event.data);
          const transcriptText = document.getElementById('transcript-text');
          const charToDelete = transcription.deleted.length;
          const newTranscriptLen = transcriptText.textContent.length - charToDelete;
          transcriptText.textContent = transcriptText.textContent.substring(0, newTranscriptLen);
          transcriptText.textContent += transcription.new;

          // Auto-scroll to bottom
          const container = document.getElementById('transcript-box');
          container.scrollTop = container.scrollHeight;
        };

        await audioContext.audioWorklet.addModule('processor.js');

        processorNode = new AudioWorkletNode(audioContext, 'pcm-processor');
        source.connect(processorNode).connect(audioContext.destination);

        processorNode.port.onmessage = (event) => {
          if (event.data.length > 0 && socket.readyState === WebSocket.OPEN) {
            const int16 = float32ToInt16(event.data);
            socket.send(int16.buffer);
          }
        };

        startBtn.disabled = true;
        stopBtn.disabled = false;
      } catch (err) {
        console.error("Error:", err);
        updateStatus("Error accessing microphone.", 'red');
      }
    });

    stopBtn.addEventListener('click', () => {
      if (processorNode) processorNode.disconnect();
      if (audioContext) audioContext.close();
      if (stream) stream.getTracks().forEach(track => track.stop());
      updateStatus("Stopped.", 'red');
      cancelAnimationFrame(animationId);
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      startBtn.disabled = false;
      stopBtn.disabled = true;
    });

    // Resize canvas to match display size
    function resizeCanvas() {
      canvas.width = canvas.clientWidth;
      canvas.height = canvas.clientHeight;
    }

    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();
  </script>
</body>
</html>

